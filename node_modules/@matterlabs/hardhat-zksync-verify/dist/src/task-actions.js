"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.checkVerificationStatus = exports.getContractInfo = exports.verifyMinimumBuild = exports.verifyContract = exports.getCompilerVersions = exports.verify = void 0;
const service_1 = require("./zksync-block-explorer/service");
const constants_1 = require("./constants");
const utils_1 = require("./utils");
const errors_1 = require("./errors");
const contract_names_1 = require("hardhat/utils/contract-names");
const chalk_1 = __importDefault(require("chalk"));
const bytecode_1 = require("./solc/bytecode");
const plugin_1 = require("./plugin");
const task_names_1 = require("hardhat/builtin-tasks/task-names");
async function verify(args, hre, runSuper) {
    if (!hre.network.zksync) {
        return await runSuper(args);
    }
    if (hre.network.verifyURL === undefined) {
        hre.network.verifyURL = constants_1.TESTNET_VERIFY_URL;
    }
    if (args.address === undefined) {
        throw new errors_1.ZkSyncVerifyPluginError(constants_1.NO_VERIFIABLE_ADDRESS_ERROR);
    }
    const constructorArguments = await hre.run(constants_1.TASK_VERIFY_GET_CONSTRUCTOR_ARGUMENTS, {
        constructorArgsModule: args.constructorArgs,
        constructorArgsParams: args.constructorArgsParams,
    });
    const libraries = await hre.run(constants_1.TASK_VERIFY_GET_LIBRARIES, {
        librariesModule: args.librariesModule,
    });
    return hre.run(constants_1.TASK_VERIFY_VERIFY, {
        address: args.address,
        constructorArguments: constructorArguments,
        contract: args.contract,
        libraries,
    });
}
exports.verify = verify;
async function getCompilerVersions(_, hre, runSuper) {
    if (!hre.network.zksync) {
        return await runSuper();
    }
    return hre.config.solidity.compilers.map((c) => c.version);
}
exports.getCompilerVersions = getCompilerVersions;
async function verifyContract({ address, contract: contractFQN, constructorArguments, libraries }, hre, runSuper) {
    if (!hre.network.zksync) {
        return await runSuper({ address, contractFQN, constructorArguments, libraries });
    }
    const { isAddress } = await Promise.resolve().then(() => __importStar(require('@ethersproject/address')));
    if (!isAddress(address)) {
        throw new errors_1.ZkSyncVerifyPluginError(`${address} is an invalid address.`);
    }
    if (!Array.isArray(constructorArguments)) {
        throw new errors_1.ZkSyncVerifyPluginError(constants_1.CONST_ARGS_ARRAY_ERROR);
    }
    const deployedBytecodeHex = await (0, utils_1.retrieveContractBytecode)(address, hre.network);
    const deployedBytecode = new bytecode_1.Bytecode(deployedBytecodeHex);
    const compilerVersions = await hre.run(constants_1.TASK_VERIFY_GET_COMPILER_VERSIONS);
    await hre.run(constants_1.TASK_COMPILE);
    const contractInformation = await hre.run(constants_1.TASK_VERIFY_GET_CONTRACT_INFORMATION, {
        contractFQN: contractFQN,
        deployedBytecode: deployedBytecode,
        matchingCompilerVersions: compilerVersions,
        libraries: libraries,
    });
    const sourceName = contractInformation.sourceName;
    const contractName = contractInformation.contractName;
    const minimumBuild = await hre.run(constants_1.TASK_VERIFY_GET_MINIMUM_BUILD, {
        sourceName: sourceName,
    });
    const solcVersion = contractInformation.solcVersion;
    const deployArgumentsEncoded = '0x' +
        (await (0, utils_1.encodeArguments)(minimumBuild.output.contracts[sourceName][contractName].abi, constructorArguments));
    const compilerPossibleVersions = await (0, service_1.getSupportedCompilerVersions)(hre.network.verifyURL);
    const compilerVersion = minimumBuild.output.version;
    if (!compilerPossibleVersions.includes(compilerVersion)) {
        throw new errors_1.ZkSyncVerifyPluginError(constants_1.COMPILER_VERSION_NOT_SUPPORTED);
    }
    const compilerZksolcVersion = 'v' + minimumBuild.output.zk_version;
    await hre.run(constants_1.TASK_VERIFY_VERIFY_MINIMUM_BUILD, {
        minimumBuild,
        contractInformation,
        address,
        compilerZksolcVersion,
        solcVersion,
        deployArgumentsEncoded,
    });
}
exports.verifyContract = verifyContract;
async function verifyMinimumBuild({ minimumBuild, contractInformation, address, compilerZksolcVersion, solcVersion, deployArgumentsEncoded, }, hre) {
    const minimumBuildContractBytecode = minimumBuild.output.contracts[contractInformation.sourceName][contractInformation.contractName].evm.bytecode
        .object;
    const matchedBytecode = contractInformation.compilerOutput.contracts[contractInformation.sourceName][contractInformation.contractName]
        .evm.bytecode.object;
    const dependencyGraph = await hre.run(task_names_1.TASK_COMPILE_SOLIDITY_GET_DEPENDENCY_GRAPH, {
        sourceNames: [contractInformation.sourceName],
    });
    contractInformation.contractName = contractInformation.sourceName + ':' + contractInformation.contractName;
    if (minimumBuildContractBytecode === matchedBytecode) {
        const request = {
            contractAddress: address,
            sourceCode: (0, plugin_1.getSolidityStandardJsonInput)(dependencyGraph.getResolvedFiles()),
            codeFormat: constants_1.JSON_INPUT_CODE_FORMAT,
            contractName: contractInformation.contractName,
            compilerSolcVersion: solcVersion,
            compilerZksolcVersion: compilerZksolcVersion,
            constructorArguments: deployArgumentsEncoded,
            optimizationUsed: true,
        };
        const response = await (0, service_1.verifyContractRequest)(request, hre.network.verifyURL);
        const verificationId = parseInt(response.message);
        console.info(chalk_1.default.cyan('Your verification ID is: ' + verificationId));
        await hre.run(constants_1.TASK_CHECK_VERIFICATION_STATUS, { verificationId: verificationId });
    }
}
exports.verifyMinimumBuild = verifyMinimumBuild;
async function getContractInfo({ contractFQN, deployedBytecode, matchingCompilerVersions, libraries }, { network, artifacts }, runSuper) {
    if (!network.zksync) {
        return await runSuper({ contractFQN, deployedBytecode, matchingCompilerVersions, libraries });
    }
    let contractInformation;
    if (contractFQN !== undefined) {
        (0, plugin_1.checkContractName)(artifacts, contractFQN);
        // Process BuildInfo here to check version and throw an error if unexpected version is found.
        const buildInfo = await artifacts.getBuildInfo(contractFQN);
        if (buildInfo === undefined) {
            throw new errors_1.ZkSyncVerifyPluginError(`We couldn't find the sources of your "${contractFQN}" contract in the project.
  Please make sure that it has been compiled by Hardhat and that it is written in Solidity.`);
        }
        const { sourceName, contractName } = (0, contract_names_1.parseFullyQualifiedName)(contractFQN);
        contractInformation = await (0, bytecode_1.extractMatchingContractInformation)(sourceName, contractName, buildInfo, deployedBytecode);
        if (contractInformation === null) {
            throw new errors_1.ZkSyncVerifyPluginError(constants_1.NO_MATCHING_CONTRACT);
        }
    }
    else {
        contractInformation = await (0, plugin_1.inferContractArtifacts)(artifacts, matchingCompilerVersions, deployedBytecode);
    }
    return contractInformation;
}
exports.getContractInfo = getContractInfo;
async function checkVerificationStatus(args, hre) {
    let isValidVerification = await (0, utils_1.executeVeificationWithRetry)(args.verificationId, hre.network.verifyURL);
    if (isValidVerification === null || isValidVerification === void 0 ? void 0 : isValidVerification.errorExists()) {
        throw new errors_1.ZkSyncVerifyPluginError(isValidVerification.getError());
    }
    console.info(chalk_1.default.green(`Contract successfully verified on zkSync block explorer!`));
}
exports.checkVerificationStatus = checkVerificationStatus;
//# sourceMappingURL=task-actions.js.map