"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Deployer = void 0;
const zk = __importStar(require("zksync-web3"));
const ethers = __importStar(require("ethers"));
const errors_1 = require("./errors");
const constants_1 = require("./constants");
const utils_1 = require("./utils");
const ZKSOLC_ARTIFACT_FORMAT_VERSION = 'hh-zksolc-artifact-1';
const ZKVYPER_ARTIFACT_FORMAT_VERSION = 'hh-zkvyper-artifact-1';
const SUPPORTED_L1_TESTNETS = ['mainnet', 'rinkeby', 'ropsten', 'kovan', 'goerli'];
/**
 * An entity capable of deploying contracts to the zkSync network.
 */
class Deployer {
    constructor(hre, zkWallet, deploymentType) {
        this.hre = hre;
        this.deploymentType = deploymentType;
        // Initalize two providers: one for the Ethereum RPC (layer 1), and one for the zkSync RPC (layer 2).
        const { ethWeb3Provider, zkWeb3Provider } = this._createProviders(hre.config.networks, hre.network);
        this.zkWallet = zkWallet.connect(zkWeb3Provider).connectToL1(ethWeb3Provider);
        this.ethWallet = this.zkWallet.ethWallet();
    }
    static fromEthWallet(hre, ethWallet, deploymentType) {
        return new Deployer(hre, new zk.Wallet(ethWallet.privateKey), deploymentType);
    }
    _createProviders(networks, network) {
        const networkName = network.name;
        if (!network.zksync) {
            throw new errors_1.ZkSyncDeployPluginError(`Only deploying to zkSync network is supported.\nNetwork '${networkName}' in 'hardhat.config' needs to have 'zksync' flag set to 'true'.`);
        }
        if (networkName === 'hardhat') {
            return {
                ethWeb3Provider: this._createDefaultEthProvider(),
                zkWeb3Provider: this._createDefaultZkProvider(),
            };
        }
        const networkConfig = network.config;
        if (!(0, utils_1.isHttpNetworkConfig)(networkConfig)) {
            throw new errors_1.ZkSyncDeployPluginError(`Only deploying to zkSync network is supported.\nNetwork '${networkName}' in 'hardhat.config' needs to have 'url' specified.`);
        }
        if (networkConfig.ethNetwork === undefined) {
            throw new errors_1.ZkSyncDeployPluginError(`Only deploying to zkSync network is supported.\nNetwork '${networkName}' in 'hardhat.config' needs to have 'ethNetwork' (layer 1) specified.`);
        }
        let ethWeb3Provider, zkWeb3Provider;
        const ethNetwork = networkConfig.ethNetwork;
        if (SUPPORTED_L1_TESTNETS.includes(ethNetwork)) {
            ethWeb3Provider =
                ethNetwork in networks && (0, utils_1.isHttpNetworkConfig)(networks[ethNetwork])
                    ? new ethers.providers.JsonRpcProvider(networks[ethNetwork].url)
                    : ethers.getDefaultProvider(ethNetwork);
        }
        else {
            ethWeb3Provider =
                ethNetwork === 'localhost'
                    ? this._createDefaultEthProvider()
                    : new ethers.providers.JsonRpcProvider(ethNetwork);
        }
        zkWeb3Provider = new zk.Provider(network.config.url);
        return { ethWeb3Provider, zkWeb3Provider };
    }
    _createDefaultEthProvider() {
        return new ethers.providers.JsonRpcProvider(constants_1.ETH_DEFAULT_NETWORK_RPC_URL);
    }
    _createDefaultZkProvider() {
        return zk.Provider.getDefaultProvider();
    }
    /**
     * Loads an artifact and verifies that it was compiled by `zksolc`.
     *
     * @param contractNameOrFullyQualifiedName The name of the contract.
     *   It can be a contract bare contract name (e.g. "Token") if it's
     *   unique in your project, or a fully qualified contract name
     *   (e.g. "contract/token.sol:Token") otherwise.
     *
     * @throws Throws an error if a non-unique contract name is used,
     *   indicating which fully qualified names can be used instead.
     *
     * @throws Throws an error if an artifact was not compiled by `zksolc`.
     */
    async loadArtifact(contractNameOrFullyQualifiedName) {
        const artifact = await this.hre.artifacts.readArtifact(contractNameOrFullyQualifiedName);
        // Verify that this artifact was compiled by the zkSync compiler, and not `solc` or `vyper`.
        if (artifact._format !== ZKSOLC_ARTIFACT_FORMAT_VERSION &&
            artifact._format !== ZKVYPER_ARTIFACT_FORMAT_VERSION) {
            throw new errors_1.ZkSyncDeployPluginError(`Artifact ${contractNameOrFullyQualifiedName} was not compiled by zksolc or zkvyper`);
        }
        return artifact;
    }
    /**
     * Estimates the price of calling a deploy transaction in ETH.
     *
     * @param artifact The previously loaded artifact object.
     * @param constructorArguments List of arguments to be passed to the contract constructor.
     *
     * @returns Calculated fee in ETH wei
     */
    async estimateDeployFee(artifact, constructorArguments) {
        const gas = await this.estimateDeployGas(artifact, constructorArguments);
        const gasPrice = await this.zkWallet.provider.getGasPrice();
        return gas.mul(gasPrice);
    }
    /**
     * Estimates the amount of gas needed to execute a deploy transaction.
     *
     * @param artifact The previously loaded artifact object.
     * @param constructorArguments List of arguments to be passed to the contract constructor.
     *
     * @returns Calculated amount of gas.
     */
    async estimateDeployGas(artifact, constructorArguments) {
        const factoryDeps = await this.extractFactoryDeps(artifact);
        const factory = new zk.ContractFactory(artifact.abi, artifact.bytecode, this.zkWallet, this.deploymentType);
        // Encode deploy transaction so it can be estimated.
        const deployTx = factory.getDeployTransaction(...constructorArguments, {
            customData: {
                factoryDeps,
            },
        });
        deployTx.from = this.zkWallet.address;
        return await this.zkWallet.provider.estimateGas(deployTx);
    }
    /**
     * Sends a deploy transaction to the zkSync network.
     * For now, it will use defaults for the transaction parameters:
     * - fee amount is requested automatically from the zkSync server.
     *
     * @param artifact The previously loaded artifact object.
     * @param constructorArguments List of arguments to be passed to the contract constructor.
     * @param overrides Optional object with additional deploy transaction parameters.
     * @param additionalFactoryDeps Additional contract bytecodes to be added to the factory dependencies list.
     *
     * @returns A contract object.
     */
    async deploy(artifact, constructorArguments = [], overrides, additionalFactoryDeps) {
        const baseDeps = await this.extractFactoryDeps(artifact);
        const additionalDeps = additionalFactoryDeps
            ? additionalFactoryDeps.map((val) => ethers.utils.hexlify(val))
            : [];
        const factoryDeps = [...baseDeps, ...additionalDeps];
        const factory = new zk.ContractFactory(artifact.abi, artifact.bytecode, this.zkWallet, this.deploymentType);
        const _a = overrides !== null && overrides !== void 0 ? overrides : {}, { customData } = _a, _overrides = __rest(_a, ["customData"]);
        // Encode and send the deploy transaction providing factory dependencies.
        const contract = await factory.deploy(...constructorArguments, Object.assign(Object.assign({}, _overrides), { customData: Object.assign(Object.assign({}, customData), { factoryDeps }) }));
        await contract.deployed();
        return contract;
    }
    /**
     * Extracts factory dependencies from the artifact.
     *
     * @param artifact Artifact to extract dependencies from
     *
     * @returns Factory dependencies in the format expected by SDK.
     */
    async extractFactoryDeps(artifact) {
        const visited = new Set();
        visited.add(`${artifact.sourceName}:${artifact.contractName}`);
        return await this.extractFactoryDepsRecursive(artifact, visited);
    }
    async extractFactoryDepsRecursive(artifact, visited) {
        // Load all the dependency bytecodes.
        // We transform it into an array of bytecodes.
        const factoryDeps = [];
        for (const dependencyHash in artifact.factoryDeps) {
            const dependencyContract = artifact.factoryDeps[dependencyHash];
            const dependencyArtifact = await this.loadArtifact(dependencyContract);
            factoryDeps.push(dependencyArtifact.bytecode);
            if (!visited.has(dependencyContract)) {
                visited.add(dependencyContract);
                const transitiveDeps = await this.extractFactoryDepsRecursive(dependencyArtifact, visited);
                factoryDeps.push(...transitiveDeps);
            }
        }
        return factoryDeps;
    }
}
exports.Deployer = Deployer;
//# sourceMappingURL=deployer.js.map